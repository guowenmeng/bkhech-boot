package org.bkhech.mybatis.extend.generator.plugins;

import org.bkhech.mybatis.extend.generator.constant.GeneratorConstant;
import org.bkhech.mybatis.extend.generator.util.GeneratorUtil;
import org.mybatis.generator.api.*;
import org.mybatis.generator.api.dom.java.*;
import org.mybatis.generator.exception.ShellException;
import org.mybatis.generator.internal.DefaultShellCallback;
import org.mybatis.generator.internal.util.StringUtility;

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * 生成继承自GenericMapper的Mapper接口
 *
 * Created by guowm on 2017/2/13.
 */
public class GenericServiceImplGeneratorPlugin extends PluginAdapter {

    private String serviceTargetDir;
    private String serviceTargetPackage;
    private String mapperTargetPackage;
    private Boolean statement;

    private ShellCallback shellCallback = null;

    public GenericServiceImplGeneratorPlugin() {
        this.shellCallback = new DefaultShellCallback(false);
    }

    @Override
    public boolean validate(List<String> list) {
        String serviceTargetDir = this.properties.getProperty("serviceTargetDir");
        this.serviceTargetDir = serviceTargetDir;
        String serviceTargetPackage = this.properties.getProperty("serviceTargetPackage");
        this.serviceTargetPackage = serviceTargetPackage;
        String mapperTargetPackage = this.properties.getProperty("mapperTargetPackage");
        this.mapperTargetPackage = mapperTargetPackage;
        String statement = this.properties.getProperty("statement");
        statement = !StringUtility.stringHasValue(statement) ? "true" : statement;
        this.statement = new Boolean(statement);
        return StringUtility.stringHasValue(serviceTargetDir) && StringUtility.stringHasValue(serviceTargetPackage);
    }

    @Override
    public List<GeneratedJavaFile> contextGenerateAdditionalJavaFiles(IntrospectedTable introspectedTable) {
        ArrayList<GeneratedJavaFile> mapperJavaFiles = new ArrayList<GeneratedJavaFile>();
        JavaFormatter javaFormatter = this.context.getJavaFormatter();

        List<IntrospectedColumn> primaryKeyColumns = introspectedTable.getPrimaryKeyColumns();

        String packageName = introspectedTable.getFullyQualifiedTable().getSubPackage(true);

        Iterator<GeneratedJavaFile> javaFilesIterator = introspectedTable.getGeneratedJavaFiles().iterator();
        while (javaFilesIterator.hasNext()) {
            GeneratedJavaFile javaFile = javaFilesIterator.next();
            CompilationUnit unit = javaFile.getCompilationUnit();
            FullyQualifiedJavaType modelJavaType = unit.getType();
            String shortName = modelJavaType.getShortName();
            if(shortName.equals(introspectedTable.getFullyQualifiedTable().getDomainObjectName()) &&
                    !shortName.endsWith("Example") && !shortName.endsWith("Mapper") && !shortName.endsWith("SqlProvider")) {
                String serviceName = shortName + "ServiceImpl";
                TopLevelClass serviceImplClass = new TopLevelClass(this.serviceTargetPackage + packageName + ".impl." + serviceName);
                serviceImplClass.setVisibility(JavaVisibility.PUBLIC);

                serviceImplClass.addJavaDocLine("/**");
                serviceImplClass.addJavaDocLine(" * ServiceImpl: " + serviceName);
                serviceImplClass.addJavaDocLine(" * Mapper : " + shortName + "Mapper");
                serviceImplClass.addJavaDocLine(" * Model  : " + shortName);
                serviceImplClass.addJavaDocLine(" *");
                serviceImplClass.addJavaDocLine(" * This ServiceImpl generated by MyBatis Generator Extend at " + GeneratorUtil.now());
                serviceImplClass.addJavaDocLine(" */");

                FullyQualifiedJavaType mapperType = new FullyQualifiedJavaType(mapperTargetPackage + packageName + "." + shortName + "Mapper");
                serviceImplClass.addImportedType(mapperType);

                Method mapperMethod = new Method();
                Field mapperField = new Field();

                mapperField.setType(mapperType);
                mapperField.setName(GeneratorUtil.convertLowerFieldName(shortName) + "Mapper");
                mapperField.setVisibility(JavaVisibility.PRIVATE);

                if (statement) {
                    FullyQualifiedJavaType autowired = new FullyQualifiedJavaType(GeneratorConstant.AUTOWIRED_CLASS_PATH);
                    FullyQualifiedJavaType service = new FullyQualifiedJavaType(GeneratorConstant.SERVICE_CLASS_PATH);
                    FullyQualifiedJavaType transactional = new FullyQualifiedJavaType(GeneratorConstant.TRANSACTIONAL_CLASS_PATH);
                    serviceImplClass.addImportedType(autowired);
                    serviceImplClass.addImportedType(service);
                    serviceImplClass.addImportedType(transactional);

                    mapperField.addAnnotation("@Autowired");
                    serviceImplClass.addAnnotation("@Service");
                    serviceImplClass.addAnnotation("@Transactional");
                }

                serviceImplClass.addField(mapperField);
                serviceImplClass.addImportedType(modelJavaType);

                if (primaryKeyColumns.size() > 0) {
                    FullyQualifiedJavaType pkType = primaryKeyColumns.size() > 1
                            ? unit.getSuperClass() : primaryKeyColumns.get(0).getFullyQualifiedJavaType();

                    FullyQualifiedJavaType superImplType = new FullyQualifiedJavaType(GeneratorConstant.GENERIC_SERVICE_IMPL_CLASS_PATH);
                    serviceImplClass.addImportedType(superImplType);
                    superImplType.addTypeArgument(modelJavaType);
                    superImplType.addTypeArgument(pkType);
                    superImplType.addTypeArgument(mapperType);
                    serviceImplClass.setSuperClass(superImplType);

                } else {
                    FullyQualifiedJavaType superImplType = new FullyQualifiedJavaType(GeneratorConstant.GENERIC_WITHOUT_PRIMARY_KEY_SERVICE_IMPL_CLASS_PATH);
                    serviceImplClass.addImportedType(superImplType);
                    superImplType.addTypeArgument(modelJavaType);
                    superImplType.addTypeArgument(mapperType);
                    serviceImplClass.setSuperClass(superImplType);
                }

                FullyQualifiedJavaType interfaceType = new FullyQualifiedJavaType(this.serviceTargetPackage + packageName + "." + shortName + "Service");
                serviceImplClass.addImportedType(interfaceType);
                serviceImplClass.addSuperInterface(interfaceType);

                mapperMethod.addBodyLine("return " + mapperField.getName() + ";");
                mapperMethod.setName("getGenericMapper");
                mapperMethod.setVisibility(JavaVisibility.PUBLIC);
                mapperMethod.addAnnotation("@Override");
                mapperMethod.setReturnType(mapperType);
                serviceImplClass.addMethod(mapperMethod);

                try {
                    GeneratedJavaFile file = new GeneratedJavaFile(serviceImplClass, this.serviceTargetDir, javaFormatter);
                    File mapperDir = this.shellCallback.getDirectory(this.serviceTargetDir, this.serviceTargetPackage + packageName + ".impl");
                    File mapperFile = new File(mapperDir, file.getFileName());
                    if(!mapperFile.exists()) {
                        mapperJavaFiles.add(file);
                    }
                } catch (ShellException e) {
                    e.printStackTrace();
                }
            }
        }
        return mapperJavaFiles;
    }

}
